---
layout: single
title:  "[백준]1022번: 소용돌이 예쁘게 출력하기"
categories: baekjoon
tag: [python, algolithm, gold, dp,BOJ]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 소용돌이 예쁘게 출력하기

[소용돌이 예쁘게 출력하기](https://www.acmicpc.net/problem/1022)

## 문제
---
크기가 무한인 정사각형 모눈종이가 있다. 모눈종이의 각 정사각형은 행과 열의 쌍으로 표현할 수 있다.

이 모눈종이 전체를 양의 정수의 소용돌이 모양으로 채울 것이다. 일단 숫자 1을 0행 0열에 쓴다. 그리고 나서 0행 1열에 숫자 2를 쓴다. 거기서 부터 소용돌이는 반시계 방향으로 시작된다. 다음 숫자는 다음과 같이 채우면 된다.

```
    -3 -2 -1  0  1  2  3
    --------------------
-3 |37 36 35 34 33 32 31
-2 |38 17 16 15 14 13 30
-1 |39 18  5  4  3 12 29
 0 |40 19  6  1  2 11 28
 1 |41 20  7  8  9 10 27
 2 |42 21 22 23 24 25 26
 3 |43 44 45 46 47 48 49
```
이 문제는 위와 같이 채운 것을 예쁘게 출력하면 된다. r1, c1, r2, c2가 입력으로 주어진다. r1, c1은 가장 왼쪽 위 칸이고, r2, c2는 가장 오른쪽 아래 칸이다.

예쁘게 출력한다는 것은 다음과 같이 출력하는 것이다.

1. 출력은 r1행부터 r2행까지 차례대로 출력한다.
2. 각 원소는 공백으로 구분한다.
3. 모든 행은 같은 길이를 가져야 한다.
4. 공백의 길이는 최소로 해야 한다.
5. 모든 숫자의 길이(앞에 붙는 공백을 포함)는 같아야 한다.
6. 만약 수의 길이가 가장 길이가 긴 수보다 작다면, 왼쪽에서부터 공백을 삽입해 길이를 맞춘다.


## 입력
---
첫째 줄에 네 정수 r1, c1, r2, c2가 주어진다.

## 출력
---
r2 - r1 + 1개의 줄에 소용돌이를 예쁘게 출력한다

## 제한
---
+ -5000 ≤ r1, c1, r2, c2 ≤ 5,000
+ 0 ≤ r2 - r1 ≤ 49
+ 0 ≤ c2 - c1 ≤ 4

## 예제 입력 1 

```
-3 -3 2 0
```

## 예제 출력 1 

```
37 36 35 34
38 17 16 15
39 18  5  4
40 19  6  1
41 20  7  8
42 21 22 23
```

## 예제 입력 2

```
-2 2 0 3
```

## 예제 출력 2 

```
13 30
12 29
11 28
```

## 예제 입력 3

```
-1 -2 -1 1
```

## 예제 출력 3

```
18  5  4  3
```

## 예제 입력 4

```
0 0 0 0
```

## 예제 출력 4

```
1
```
 
# 풀이

**점화식**

```python
dp[i][j] = max(dp[i - 1][j - cost[i]] + memory[i], dp[i - 1][j])
```
- for i in range(메모리 갯수 + 1)
    - for j in range(최대 코스트 + 1)
        - i번째 메모리를 체크한다.
        - j는 cost의 증가과정이다.
        - j가 i번째 cost보다 크거나 같은지 확인한다.
        - [i - 1번째 메모리][j코스트]에 저장되어 있는 확보한 최대 메모리가 [i - 1번째 메모리][j코스트 - i번째 메모리의 코스트] 와 i번째 메모리의 합과 비교해서 가장 큰 값으로 업데이트 해준다. 
        - 업데이트한 결과가 확보해야 하는 메모리인 M보다 크거나 같은지 체크
            - 만약 크거나 같다면 min_cost와 비교하여 min_cost 업데이트

```python
import sys

ans_minus = []
ans_plus = []
a = 4

for i in range(5002):
    if i == 0:
        ans_minus.append(1)
        ans_plus.append(1)
    elif i == 1:
        ans_minus.append(5)
        ans_plus.append(2)
    else:
        a += 8
        ans_minus.append(ans_minus[-1] + a)
        ans_plus.append(ans_plus[-1] + a - 4)

r1, c1, r2, c2 = map(int, sys.stdin.readline().split())

x = abs(r1 - r2) + 1
y = abs(c1 - c2) + 1

hurricane = [[0] * y for _ in range(x)]


for i in range(x):
    for j in range(y):
        real_x = i + r1
        real_y = j + c1
        if abs(real_x) > abs(real_y):
            if real_x < 0:
                hurricane[i][j] = ans_minus[abs(real_x)] - abs(real_x - real_y)
            elif real_x > 0:
                hurricane[i][j] = ans_plus[abs(real_x) + 1] - abs(real_x - real_y) -1 
        elif abs(real_x) < abs(real_y):
            if real_y > 0:
                hurricane[i][j] = ans_plus[abs(real_y)] + abs(real_x - real_y) -1
            elif real_y < 0:
                hurricane[i][j] = ans_minus[abs(real_y)] + abs(real_x - real_y)
        elif abs(real_x) == abs(real_y):
            if real_x < 0:
                hurricane[i][j] = ans_minus[abs(real_x)] - abs(real_x - real_y)
            elif real_x > 0:
                hurricane[i][j] = ans_plus[abs(real_x) + 1] - abs(real_x - real_y) - 1 
        if hurricane[i][j] == 0:
            hurricane[i][j] = 1
max_num = 0
for i in range(x):
    max_hurricane = max(hurricane[i])
    max_num = max(max_hurricane, max_num)

max_num_len = len(str(max_num))

for i in range(x):
    for j in range(y):
        a = len(str(hurricane[i][j]))
        if a < max_num_len:
            b = " " * (max_num_len - a)
            b += str(hurricane[i][j])
            print(b, end = " ")
        else:
            print(hurricane[i][j], end = " ")
    print()
```

# 고찰

- 솔직히 말해서 배낭 문제 해결법을 알지 못한다고 하여도 dp를 자세히 공부했으면 풀 수 있다.
- 하지만 점화식을 구하는 과정이 너무 어려워서 배낭 문제 해결법을 보게 되었다.
- dp 문제를 더욱더 많이 풀면서 점화식에 익숙해져야겠다.
- 이러한 메모리 같은 경우는 정해진 메모리에서 더 쪼갤수가 없다.
- 하지만 쪼갤수 있는 것이 들어온다면 dp가 아닌 그리디로 풀도록 하자!