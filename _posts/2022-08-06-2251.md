---
layout: single
title:  "[백준]2251번: 물통"
categories: baekjoon
tag: [python, algolithm, gold, dp,BOJ]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 물통

[물통](https://www.acmicpc.net/problem/2251)

## 문제
---
각각 부피가 A, B, C(1≤A, B, C≤200) 리터인 세 개의 물통이 있다. 처음에는 앞의 두 물통은 비어 있고, 세 번째 물통은 가득(C 리터) 차 있다. 이제 어떤 물통에 들어있는 물을 다른 물통으로 쏟아 부을 수 있는데, 이때에는 한 물통이 비거나, 다른 한 물통이 가득 찰 때까지 물을 부을 수 있다. 이 과정에서 손실되는 물은 없다고 가정한다.

이와 같은 과정을 거치다보면 세 번째 물통(용량이 C인)에 담겨있는 물의 양이 변할 수도 있다. 첫 번째 물통(용량이 A인)이 비어 있을 때, 세 번째 물통(용량이 C인)에 담겨있을 수 있는 물의 양을 모두 구해내는 프로그램을 작성하시오.


## 입력
---
첫째 줄에 세 정수 A, B, C가 주어진다.

## 출력
---
첫째 줄에 공백으로 구분하여 답을 출력한다. 각 용량은 오름차순으로 정렬한다.


## 예제 입력 1 

```
8 9 10
```

## 예제 출력 1 

```
1 2 8 9 10
```
 
# 풀이

**점화식**

```python
dp[i][j] = max(dp[i - 1][j - cost[i]] + memory[i], dp[i - 1][j])
```
- for i in range(메모리 갯수 + 1)
    - for j in range(최대 코스트 + 1)
        - i번째 메모리를 체크한다.
        - j는 cost의 증가과정이다.
        - j가 i번째 cost보다 크거나 같은지 확인한다.
        - [i - 1번째 메모리][j코스트]에 저장되어 있는 확보한 최대 메모리가 [i - 1번째 메모리][j코스트 - i번째 메모리의 코스트] 와 i번째 메모리의 합과 비교해서 가장 큰 값으로 업데이트 해준다. 
        - 업데이트한 결과가 확보해야 하는 메모리인 M보다 크거나 같은지 체크
            - 만약 크거나 같다면 min_cost와 비교하여 min_cost 업데이트

```python
import sys

ans_minus = []
ans_plus = []
a = 4

for i in range(5002):
    if i == 0:
        ans_minus.append(1)
        ans_plus.append(1)
    elif i == 1:
        ans_minus.append(5)
        ans_plus.append(2)
    else:
        a += 8
        ans_minus.append(ans_minus[-1] + a)
        ans_plus.append(ans_plus[-1] + a - 4)

r1, c1, r2, c2 = map(int, sys.stdin.readline().split())

x = abs(r1 - r2) + 1
y = abs(c1 - c2) + 1

hurricane = [[0] * y for _ in range(x)]


for i in range(x):
    for j in range(y):
        real_x = i + r1
        real_y = j + c1
        if abs(real_x) > abs(real_y):
            if real_x < 0:
                hurricane[i][j] = ans_minus[abs(real_x)] - abs(real_x - real_y)
            elif real_x > 0:
                hurricane[i][j] = ans_plus[abs(real_x) + 1] - abs(real_x - real_y) -1 
        elif abs(real_x) < abs(real_y):
            if real_y > 0:
                hurricane[i][j] = ans_plus[abs(real_y)] + abs(real_x - real_y) -1
            elif real_y < 0:
                hurricane[i][j] = ans_minus[abs(real_y)] + abs(real_x - real_y)
        elif abs(real_x) == abs(real_y):
            if real_x < 0:
                hurricane[i][j] = ans_minus[abs(real_x)] - abs(real_x - real_y)
            elif real_x > 0:
                hurricane[i][j] = ans_plus[abs(real_x) + 1] - abs(real_x - real_y) - 1 
        if hurricane[i][j] == 0:
            hurricane[i][j] = 1
max_num = 0
for i in range(x):
    max_hurricane = max(hurricane[i])
    max_num = max(max_hurricane, max_num)

max_num_len = len(str(max_num))

for i in range(x):
    for j in range(y):
        a = len(str(hurricane[i][j]))
        if a < max_num_len:
            b = " " * (max_num_len - a)
            b += str(hurricane[i][j])
            print(b, end = " ")
        else:
            print(hurricane[i][j], end = " ")
    print()
```

# 고찰

- 솔직히 말해서 배낭 문제 해결법을 알지 못한다고 하여도 dp를 자세히 공부했으면 풀 수 있다.
- 하지만 점화식을 구하는 과정이 너무 어려워서 배낭 문제 해결법을 보게 되었다.
- dp 문제를 더욱더 많이 풀면서 점화식에 익숙해져야겠다.
- 이러한 메모리 같은 경우는 정해진 메모리에서 더 쪼갤수가 없다.
- 하지만 쪼갤수 있는 것이 들어온다면 dp가 아닌 그리디로 풀도록 하자!