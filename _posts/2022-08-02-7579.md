---
layout: single
title:  "[백준]7579번: 앱"
categories: baekjoon
tag: [python, algolithm, gold, dp,BOJ]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 앱

[앱](https://www.acmicpc.net/problem/7579)

## 문제

우리는 스마트폰을 사용하면서 여러 가지 앱(App)을 실행하게 된다. 대개의 경우 화면에 보이는 ‘실행 중’인 앱은 하나뿐이지만 보이지 않는 상태로 많은 앱이 '활성화'되어 있다. 앱들이 활성화 되어 있다는 것은 화면에 보이지 않더라도 메인 메모리에 직전의 상태가 기록되어 있는 것을 말한다. 현재 실행 중이 아니더라도 이렇게 메모리에 남겨두는 이유는 사용자가 이전에 실행하던 앱을 다시 불러올 때에 직전의 상태를 메인 메모리로부터 읽어 들여 실행 준비를 빠르게 마치기 위해서이다.

하지만 스마트폰의 메모리는 제한적이기 때문에 한번이라도 실행했던 모든 앱을 활성화된 채로 메인 메모리에 남겨두다 보면 메모리 부족 상태가 오기 쉽다. 새로운 앱을 실행시키기 위해 필요한 메모리가 부족해지면 스마트폰의 운영체제는 활성화 되어 있는 앱들 중 몇 개를 선택하여 메모리로부터 삭제하는 수밖에 없다. 이러한 과정을 앱의 ‘비활성화’라고 한다.

메모리 부족 상황에서 활성화 되어 있는 앱들을 무작위로 필요한 메모리만큼 비활성화 하는 것은 좋은 방법이 아니다. 비활성화된 앱들을 재실행할 경우 그만큼 시간이 더 필요하기 때문이다. 여러분은 이러한 앱의 비활성화 문제를 스마트하게 해결하기 위한 프로그램을 작성해야 한다

현재 N개의 앱, A1, ..., AN이 활성화 되어 있다고 가정하자. 이들 앱 Ai는 각각 mi 바이트만큼의 메모리를 사용하고 있다. 또한, 앱 Ai를 비활성화한 후에 다시 실행하고자 할 경우, 추가적으로 들어가는 비용(시간 등)을 수치화 한 것을 ci 라고 하자. 이러한 상황에서 사용자가 새로운 앱 B를 실행하고자 하여, 추가로 M 바이트의 메모리가 필요하다고 하자. 즉, 현재 활성화 되어 있는 앱 A1, ..., AN 중에서 몇 개를 비활성화 하여 M 바이트 이상의 메모리를 추가로 확보해야 하는 것이다. 여러분은 그 중에서 비활성화 했을 경우의 비용 ci의 합을 최소화하여 필요한 메모리 M 바이트를 확보하는 방법을 찾아야 한다.

## 입력

입력은 3줄로 이루어져 있다. 첫 줄에는 정수 N과 M이 공백문자로 구분되어 주어지며, 둘째 줄과 셋째 줄에는 각각 N개의 정수가 공백문자로 구분되어 주어진다. 둘째 줄의 N개의 정수는 현재 활성화 되어 있는 앱 A1, ..., AN이 사용 중인 메모리의 바이트 수인 m1, ..., mN을 의미하며, 셋째 줄의 정수는 각 앱을 비활성화 했을 경우의 비용 c1, ..., cN을 의미한다

단, 1 ≤ N ≤ 100, 1 ≤ M ≤ 10,000,000이며, 1 ≤ m1, ..., mN ≤ 10,000,000을 만족한다. 또한, 0 ≤ c1, ..., cN ≤ 100이고, M ≤ m1 + m2 + ... + mN이다.

## 출력

필요한 메모리 M 바이트를 확보하기 위한 앱 비활성화의 최소의 비용을 계산하여 한 줄에 출력해야 한다. 

## 예제 입력 1 

```
5 60
30 10 20 35 40
3 0 3 5 4
```

## 예제 출력 1 

```
6
```


# 문제 해석

- 배낭 알고리즘을 이용하는 문제이다.
- 여기서 비용을 기준으로 할지, 메모리를 기준으로 할지가 중요하다.
- 비용을 **최소화**하면서 메모리를 60을 넘겨야한다.
- 비용이 최소이려면 비용이 1씩 증가하면서 메모리가 최대로 많이 증가해야 적은 비용으로 메모리 60이상을 확보할 수 있다.
- 표를 그려보도록 하자

## 예시

```
5 60
30 10 20 35 40
3 0 3 5 4
```

| |0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|
|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|:---|
||0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|
|"메모리1"|0|0|0|30|30|30|30|30|30|30|30|30|30|30|30|30|
|"메모리2"|10|10|10|40|40|40|40|40|40|40|40|40|40|40|40|40|
|"메모리3"|10|10|10|40|40|40|60|60|60|60|60|60|60|60|60|60|
|"메모리4"|10|10|10|40|40|45|60|60|75|75|75|95|95|95|95|95|
|"메모리5"|10|10|10|40|50|50|60|80|80|85|100|100|115|115|115|135|

- 비용은 아무리 많이 나와봤자 3 + 0 + 3 + 5 + 4 = 15 이다.
- 비용이 1개씩 증가하면서 메모리가 최대치로 나오게 설정을 해야 한다.
- 왜냐하면 비용이 하나씩 증가할때 메모리가 최대로 증가해서 최대한 빨리 60이라는 숫자를 넘어야 최소의 비용을 쓰면서 메모리 공간을 확보하는 것이기 때문이다.
 
# 풀이

**점화식**

```python
dp[i][j] = max(dp[i - 1][j - cost[i]] + memory[i], dp[i - 1][j])
```
- for i in range(메모리 갯수 + 1)
    - for j in range(최대 코스트 + 1)
        - i번째 메모리를 체크한다.
        - j는 cost의 증가과정이다.
        - j가 i번째 cost보다 크거나 같은지 확인한다.
        - [i - 1번째 메모리][j코스트]에 저장되어 있는 확보한 최대 메모리가 [i - 1번째 메모리][j코스트 - i번째 메모리의 코스트] 와 i번째 메모리의 합과 비교해서 가장 큰 값으로 업데이트 해준다. 
        - 업데이트한 결과가 확보해야 하는 메모리인 M보다 크거나 같은지 체크
            - 만약 크거나 같다면 min_cost와 비교하여 min_cost 업데이트

```python
import sys

N, M = map(int, sys.stdin.readline().split())

m = list(map(int, sys.stdin.readline().split()))
c = list(map(int, sys.stdin.readline().split()))

max_cost = sum(c)
min_cost = 10 ** 9

dp = [[0] * (max_cost + 1) for _ in range(N + 1)]

for i in range(1, N + 1):
    for j in range(max_cost + 1):
        if j < c[i - 1]:
            dp[i][j] = dp[i - 1][j]
        else:
            dp[i][j] = max(dp[i - 1][j - c[i - 1]] + m[i - 1], dp[i - 1][j])
        if dp[i][j] >= M:
            if min_cost > j:
                min_cost = j

print(min_cost)
```

# 고찰

- 솔직히 말해서 배낭 문제 해결법을 알지 못한다고 하여도 dp를 자세히 공부했으면 풀 수 있다.
- 하지만 점화식을 구하는 과정이 너무 어려워서 배낭 문제 해결법을 보게 되었다.
- dp 문제를 더욱더 많이 풀면서 점화식에 익숙해져야겠다.
- 이러한 메모리 같은 경우는 정해진 메모리에서 더 쪼갤수가 없다.
- 하지만 쪼갤수 있는 것이 들어온다면 dp가 아닌 그리디로 풀도록 하자!